1. Some pros to using linked lists instead of arrays are: there are never empty placeholders, it saves memory which in turn can save money, and they are able to be as large as they want because of node memory independence.
As with everything, there are some cons to using linked lists. It could make accessing elements inefficient because each node can exist anywhere in the memory.

2. A linked list is something like a scavenger hunt. You get a clue, and that clue helps you to find the next clue. So you go to the next place and get another piece of information or another clue. The only way to get information from the middle or end of the scavenger hunt is to follow the list from the beginning until the end.

Programming

1.
LinkedList.prototype.push = function(val){
    var node = {
       value: val,
       next: null
    }

    if(!this.head){
      this.head = node;
      this.length += 1;
      return node;
    }
    else{
      current = this.head;
      while(current.next){
        current = current.next;
      }

      current.next = node;
      this.length += 1;
      return node;
    }
  }

There is no while loop in pseudocode, which is a way to move from node to node on the list. There is a current-next, where current equals the next node and not null.

2.
function LinkedList(){
  this.head= null;
  this.length=0;
}

LinkedList.prototype.push = function(val){
    var node = {
       value: val,
       next: null
    }

    if(!this.head){
      this.head = node;
      this.length += 1;
      return node;
    }
    else{
      current = this.head;
      while(current.next){
        current = current.next;
      }
      current.next = node;
      this.length += 1;
      return node;
    }
  }

LinkedList.prototype.duplicate = function(){
 if (!this.head || !this.head.next) {
      console.log("no duplicate");
      return;
  }

    var thisNode = this.head;
    while (thisNode != null) {
      var previousNode = thisNode;
      var nextNode = thisNode.next;
      while (nextNode != null) {
        if (thisNode.value == nextNode.value) {
          previousNode.next = nextNode.next;
          this.length --;
        } else {
          previousNode = nextNode;
        }
        nextNode = nextNode.next;
      }
      thisNode = thisNode.next;
    }
    return this;
  }

list= new LinkedList()
list.push(5);
list.push(4);
list.push(3);
list.push(2);
list.duplicate()

3.
function LinkedList(){
  this.head= null;
  this.length=0;
}

LinkedList.prototype.push = function(val){
    var node = {
       value: val,
       next: null
    }

    if(!this.head){
      this.head = node;
      this.length += 1;
      return node;
    }
    else{
      current = this.head;
      while(current.next){
        current = current.next;
      }
      current.next = node;
      this.length += 1;
      return node;
    }
  }

LinkedList.prototype.duplicate = function(){
 if (!this.head || !this.head.next) {
      console.log("no duplicates");
  }

    var thisNode = this.head;
    while (thisNode != null) {
      var previousNode = thisNode;
      var nextNode = thisNode.next;
      while (nextNode != null) {
        if (thisNode.value == nextNode.value) {
          previousNode.next = nextNode.next;
          this.length --;
        } else {
          previousNode = nextNode;
        }
        nextNode = nextNode.next;
      }
      thisNode = thisNode.next;
    }
    return this;
  }

LinkedList.prototype.reverse= function() {
    var previousNode = null;
    var thisNode = this.head;
    var nextNode;

    while (thisNode) {
      nextNode = thisNode.next;
      thisNode.next = previousNode;
      previousNode = thisNode;
      thisNode = nextNode;
    }

    this.head = previousNode;
  }



list= new LinkedList()
list.push(5);
list.push(4);
list.push(2);
list.push(3);
list.reverse()
