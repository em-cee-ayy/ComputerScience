1. A binary tree is a data structure where each Node can point to a left child and a right child.  These are unique because they can only have up to two children per node.

2. A heuristic is a guess that an algorithm makes in attempt to quickly solve a complex problem, but it sacrifices accuracy.

3. Another problem that uses heuristics would be some medical cases, virus scans, and scientific problems.

4. A breadth first search is a search where you start at the root node, and then scan each node in the first level starting from the left node, moving towards the right. A depth first search is a search where you start at the root and follow one of the branches of the tree as far as possible until either the node you are looking for is found or you hit a leaf node.

5. It's a graph where the connection between nodes does not have a start or an end, does not have loops, and does not take into consideration the weight between nodes.

6. Directed, a-cyclic, unweighted

Programming Questions

1.
class Node {
  constructor(data, left = null, right = null) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BST {
  constructor() {
    this.root = null;
  }
  add(data) {
    const node = this.root;
    if (node === null) {
      this.root = new Node(data);
      return;
    } else {
      const searchTree = function(node) {
        if (data < node.data) {
          if (node.left === null) {
            node.left = new Node(data);
            return;
          } else if (node.left !== null) {
            return searchTree(node.left);
          }
        } else if (data > node.data) {
          if (node.right === null) {
            node.right = new Node(data);
            return;
          } else if (node.right !== null) {
            return searchTree(node.right);
          }
        } else {
          return null;
        }
      };
      return searchTree(node);
    }
  }
  find(data) {
    let current = this.root;
    while (current.data !== data) {

      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
      if (current === null) {
        return null;
      }
    }
    return current;
}
  isPresent(data) {
    let current = this.root;
    while (current) {
      if (data === current.data) {
        return true;
      }
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    return false;
  }

}

const bst = new BST();

bst.add(10);
bst.add(3);
bst.add(14);
bst.add(6);
bst.add(1);
bst.add(13);
bst.add(7);
bst.add(4);

2.
class Node
{
	constructor(data)
	{
		this.data = data;
		this.left = null;
		this.right = null;
	}
}


class BinarySearchTree
{
	constructor()
	{

		this.root = null;
	}



add(data)
{

	var newNode = new Node(data);


	if(this.root === null)
    {this.root = newNode;}
	else


    {this.insertNode(this.root, newNode);}
}


insertNode(node, newNode)
{

	if(newNode.data < node.data)
	{

		if(node.left === null)
        {node.left = newNode;}
		else


        {this.insertNode(node.left, newNode);}
	}


	else
	{

		if(node.right === null)
        {node.right = newNode;}
		else


        {this.insertNode(node.right,newNode);}
	}
}

isPresent(data) {
   let current = this.root;

   while (current) {

     if (data === current.data) {
        return true;
      }
     if (data < current.data) {
        current = current.left;
   } else {
        current = current.right;
      }
    }
    return false;
  }

findLCA(root,n1,n2){
  let ancestor = this.root;

  while (ancestor){
    if ((n1 < ancestor.data && n2 > ancestor.data)|| (n1 > ancestor.data && n2 < ancestor.data)){
      return ancestor.data;
    }
    if (n1 < ancestor.data && n2 < ancestor.data){
      ancestor = ancestor.left;
    }
    else if (n1 > ancestor.data && n2 > ancestor.data) {
      ancestor = ancestor.right;
    }
  }
  return ancestor.data;
}

path(root, node){
  let current = this.root;
  let i = 0;
  while (current && current.data != node){
    if (node < current.data){
      current = current.left;
    }
    else {
      current = current.right;
    }
    i++;
  }
  return i;
}

distanceOfNodes (root,n1,n2){
  let LCA = this.findLCA(root,n1,n2);

  let distance = this.path(LCA,n1)+this.path(LCA,n2);
  return distance;
}
}

var test = new BinarySearchTree();
test.add(8);
test.add(3);
test.add(10);
test.add(1);
test.add(6);
test.add(14);
test.add(4);
test.add(7);
test.add(13);
